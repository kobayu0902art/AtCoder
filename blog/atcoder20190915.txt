https://atcoder.jp/contests/abc141/tasks

提出コードは最後に

【結果】
A,B:完答
C,D:TLE
300点

【感想】
C,DのTLEめちゃくちゃ悔しい
テストケースはすべて正常に消化できていたので、コード自体は間違っていないはず
しかしいままで実行時間を気にしたコーディングをしてこなかったので、そもそも実行時間の少ないコードが書けないし、TLEが出たときに具体的にどうしたらいいかが分からなかった。
これから知識、スニペットを蓄え、ある程度のパターンに対して最適なアルゴリズムを選択できるようにし、今回のようなTLEによる得点ロスをなくしていきたい。

今回は知識が足りなかったことから、TLEへの対策ができなかったと思われるが、
B問題に時間をかけすぎて他の問題に対して細かい配慮ができなかったことが今回の大きな反省点。
初挑戦とはいえ、WAとなったときに焦りすぎ

今回はTLEとなってしまったが、Dに関しては問題自体にたいする解答はすぐ出てきたので、得点の低いA,Bから素直に解くのではなく、
C,Dに一度手を付けてみるのもいいかもしれない

誤答提出後の5分ペナルティが思っていた以上にキッツい
特に終盤、「これさえ直せば…」みたいなときかなり悔しい
あと、テスト用のprint文が残ったまま提出しちゃったりとかでペナルティ食らうのホントしょーもない
やめよう

pythonでプログラムを書き始めてそろそろ半年になるが、最初に覚えたプログラミング言語がC言語であることから、まだC脳が抜けず、
pythonicな書き方が定着しない。forループの多用が主に顕著な例であり、同時に致命的な弱点だと思われる。ネストなんてしようもんならTLE待ったなしである。


【A - Weather Prediction】
https://atcoder.jp/contests/abc141/tasks/abc141_a

読み込んだ文字列に対してifで分岐を合計3つ

所要時間は5分ほど

【B - Tap Dance】
https://atcoder.jp/contests/abc141/tasks/abc141_b

ここに時間をかけすぎたのが今回の大きな敗因の一つ

圧倒的にコードが汚い
分岐条件を愚直に R or U or Dなどと書いてしまい、しかも正常に動作しないと散々だった。
15分使ってから補集合(?)に気づき修正するも、失った時間は取り戻せず

文字数に対する挙動が必要なことに全く気付かず、さらに15分を使ってしまう。

以上が主な反省点

所要時間は35分

今回の結果を踏まえて:
https://atcoder.jp/contests/abs/tasks/arc065_a
上記問題など、文字列を使った操作、特に不定長の文字列を扱う問題が苦手な傾向
似たような問題に対してあらかじめ対策となるスニペットを用意しておく。
加えて、文字列操作における注意点を洗い出すことが必要

【C - Attack Survival】
https://atcoder.jp/contests/abc141/tasks/abc141_c

Bで時間をかけすぎたショックから、問題文の理解、入力と出力の対応の理解に時間がかかってしまう。メンタル弱すぎ

リストで参加者のポイントを管理し、その値でYesNoを出力する方針に決めたのが着手しはじめてから5分後
n,k,q,参加者のポイントと、4つの値を頭の中で関連を正しく整理するのが難しかった。
おかげでどのリスト、値を使うのか、[]内にどれを使ったらいいのかの「判断が遅い」
あと、リストの番地が0始まりなのと参加者の番号が1始まりなのも混乱した。
このへんはそもそもリストとか配列の感覚がまだまだ反射レベルで身についていないことの証明となってしまった。

上記のことを修正したとしても、TLEは解決しない。
以前から指摘されていたことではあったが、pythonのforループは死ぬほど遅い。
10^9回のforループとか致命的なんだろうなあ
後述するが、D問題についてはTLEについての解答がすでにわかっているが、この問題についてはどこを改善したらいいかわからないので、引き続き
インターネットの諸先輩方に学ばせていただく。

所要時間は35分

【D - Powerful Discount Tickets】
https://atcoder.jp/contests/abc141/tasks/abc141_d

この問題はぶっちゃけ簡単だった。
"TLEがなければ"!!!

問題文の把握にほとんど時間がかからず、完答を確信した。
X/2^Y円…などと難しそうなヤラシイ書き方をしているが、要は半額になるということはすぐに分かった。
全体的に遠回しな表現だが、価格最大のものに割引券を使えば最大効率になることがわかったので、
価格リストを降順にソートし、先頭に割引券を適用、ソートしなおすことで答えになると考えた。
コードが8行におさまり、すべての入力例に対して正しい出力が出せていたので、ドヤ顔で提出し、400点獲得を確信した。
だが結果はTLE。
python3ではなくpypy3で提出すると実行時間が短くなると聞いていたので、pypy3で提出してもTLEは解決しなかった。
テストケースがすべて消化できているから余計に焦る。
この辺でペナルティの重さを実感する。
結局この問題で100分が経過し、初挑戦が終わった。

後日検証したところ、やはりforループが遅い。
nがどれだけ大きくなろうが実行時間にほとんど影響しなかったが、試した限りでもmが50000あたりで実行時間制限の2secがあやしくなる。
入力制約は100000。これでは仕様にこたえているとはいえないなあ
やはりpythonのforは遅い。
解決法を求めて調べていたところ、sortもかなり遅くなる原因であることが分かった。しかし9/15時点で他にリストをソートする方法など知らなかったのでこれは完全に知識不足。
https://qiita.com/ellio08/items/fe52a9eb9499b7060ed6
優先度付きキューを使うと計算量が減らせるらしい。
これからもリストのソートは使うと思うので、知識、スニペットとしてためておき、必要なときに使えるように定着させていきたい。

所要時間は25分
最初の提出まではテスト含め10分未満

【提出コード】
【A - Weather Prediction】
s=input()

if s =="Sunny":
    print("Cloudy")
elif s == "Cloudy":
    print("Rainy")
elif s == "Rainy":
    print("Sunny")
【B】
s=input()

def evenjudge(obj):
    if obj %2!=0:
        return 1
    else:
        return 2
def oddjudge(obj):
    if obj %2!=0:
        return 2
    else:
        return 1

lo=[i for i in range(0,110,2)]
le=[i for i in range(1,110,2)]

oeflag=evenjudge(len(s))
eoflag=oddjudge(len(s))
for j in lo:
    if s[j] == "L":
        print("No")
        exit(0)
    if j == len(s)-oeflag:
        break


for k in le:
    if len(s)==1:
        break
    if s[k] == "R":
        print("No")
        exit(0)
    if k == len(s)-eoflag:
        break


print("Yes")

【C】
n,k,q=(int(x) for x in input().split())
a=[]
for i in range(q):
    a.append(int(input()))
p=[0]*n
for i in range(k):
    for j in range(n):
        p[j]+=1
for i in range(n):
    for j in range(q):
        p[i]-=1
        if a[j]-1 == i:
            p[i]+=1


for i in range(n):
    if p[i]>0:
        print("Yes")
    else:
        print("No")

【D】
n,m=(int(x) for x in input().split())
l = [int(i) for i in input().split()]

l.sort(reverse=True)
for i in range(m):
    l[0]=l[0]//2
    l.sort(reverse=True)
total=sum(l)

print(total)
 
